{"name":"Libsigsegv","tagline":"Mirror of git://git.savannah.gnu.org/libsigsegv.git","body":"           GNU libsigsegv  -  Handling page faults in user mode\r\n\r\nThis is a library for handling page faults in user mode. A page fault\r\noccurs when a program tries to access to a region of memory that is\r\ncurrently not available. Catching and handling a page fault is a useful\r\ntechnique for implementing:\r\n\r\n  - pageable virtual memory,\r\n  - memory-mapped access to persistent databases,\r\n  - generational garbage collectors,\r\n  - stack overflow handlers,\r\n  - distributed shared memory,\r\n  - ...\r\n\r\nThis library supports three sets of functions, all defined in <sigsegv.h>:\r\n\r\n  - Global SIGSEGV handlers:\r\n    sigsegv_install_handler, sigsegv_deinstall_handler.\r\n\r\n  - Local SIGSEGV handlers (a handler per memory area):\r\n    sigsegv_init, sigsegv_register, sigsegv_unregister, sigsegv_dispatch.\r\n\r\n  - Stack overflow handlers:\r\n    stackoverflow_install_handler, stackoverflow_deinstall_handler.\r\n\r\nEach of the three APIs can be used independently or simultaneously.\r\nFor examples of the use of the APIs, see:\r\n\r\n  - Global SIGSEGV handlers: see tests/sigsegv1.c.\r\n  - Local SIGSEGV handlers: see tests/sigsegv2.c.\r\n  - Stack overflow handlers: see tests/stackoverflow1.c.\r\n\r\n\r\nAbout portability.\r\n\r\nSome platforms don't support this functionality. In <sigsegv.h>, the\r\npreprocessor macro HAVE_SIGSEGV_RECOVERY will be defined if global and\r\nlocal SIGSEGV handlers are available, and the preprocessor macro\r\nHAVE_STACK_OVERFLOW_RECOVERY will be defined if stack overflow handlers\r\nare available. Note that the declared functions are available in all cases;\r\non platforms where HAVE_SIGSEGV_RECOVERY or HAVE_STACK_OVERFLOW_RECOVERY is\r\nnot defined, they will simply always return an error code or do nothing.\r\n\r\nThe list of platforms where this library is known to work is contained in\r\nthe file PORTING.\r\n\r\n\r\nAbout pageable virtual memory.\r\n\r\nPageable virtual memory is usually done in the operating system's kernel.\r\nThis library helps in implementing the others.\r\n\r\nInstalling a page fault handler is usually more efficient than doing\r\naccess checks in software at every access, because it's effectively the\r\nhardware (the MMU) which checks whether a page is present or not.\r\n\r\nNote that if you use system calls (like read()) to write into write-\r\nprotected pages, the system will react by returning -1 and setting\r\nerrno to EFAULT, instead of signalling SIGSEGV and restarting the system\r\ncall. In this case, the program has to do what the SIGSEGV handler would\r\ndo, and then restart the read() operation. Some buggy systems (SunOS 4)\r\ngo into an endless loop on this occasion; on these systems you have to\r\nmake sure that an area is writable _before_ you call read() on it,\r\n\r\n\r\nAbout stack overflow handlers.\r\n\r\nIn some applications, the stack overflow handler performs some cleanup or\r\nnotifies the user and then immediately terminates the application.  In\r\nother applications, the stack overflow handler longjmps back to a central\r\npoint in the application.  This library supports both uses.  In the second\r\ncase, the handler must ensure to restore the normal signal mask (because\r\nmany signals are blocked while the handler is executed), and must also\r\ncall sigsegv_leave_handler() to transfer control; then only it can longjmp\r\naway.\r\n\r\nNote that longjmping back to a central point in the application can leave\r\nthe application in an inconsistent state, because\r\n  1) no cleanup is executed for call frames that are being unwound,\r\n  2) the code being executed while the stack overflow occurred might leave\r\n     data structures in an intermediate, inconsistent state.\r\nIf you want to avoid the first problem, you need to restructure your\r\napplication into three or more threads:\r\n  - a main thread, which creates the other threads,\r\n  - worker threads, which may cause stack overflows, and in which all\r\n    cleanups are registered through the pthread_cleanup_push function,\r\n  - a handler thread, which contains the handler for stack overflow and\r\n    other kinds of SIGSEGV. The handler will call pthread_cancel on the\r\n    worker thread whose stack overflowed.\r\nYou will need to use the function pthread_sigmask on all threads except\r\nthe handler thread, in order to ensure that the SIGSEGV signal gets handled\r\nin the designated handler thread.\r\nIf you want to avoid the second problem together with the first problem,\r\nyou need to enclose code that manipulates data structures in a way that is\r\nnot safe to be interrupted within calls to pthread_setcancelstate() or\r\npthread_setcanceltype().\r\nIf you want to avoid just the second problem, you need to manipulate all data\r\nstructures in a way that is safe to be interrupted at any moment and also\r\ncompile your program with the gcc flag -fnon-call-exceptions.\r\n\r\n\r\nAbout shared libraries.\r\n\r\nThis library builds as a static library by default.  This seems useful\r\nbecause of the small size of the library (4 KB).  Of course, you can build\r\nit as a shared library by specifying the configure option '--enable-shared'.\r\n\r\n\r\nInstallation\r\n------------\r\n\r\nInstallation instructions on Unix:\r\n\r\n        ./configure [OPTIONS]\r\n        make\r\n        make check\r\n        make install\r\n\r\nInstallation instructions on Woe32:\r\n\r\n        See README.woe32.\r\n\r\n\r\nUsing libsigsegv in your package:\r\n  - For the APIs, see the comments in the <sigsegv.h> file (generated from\r\n    src/sigsegv.h.in).\r\n  - An autoconf macro for determining where libsigsegv is installed and how to\r\n    link with it is part of GNU gnulib, see\r\n    <http://www.gnu.org/software/gnulib/MODULES.html#module=libsigsegv>\r\n\r\n\r\nCopyright notice\r\n----------------\r\n\r\nCopyright 1998-1999, 2002-2011  Bruno Haible <bruno@clisp.org>\r\nCopyright 2002-2005, 2009  Paolo Bonzini <bonzini@gnu.org>\r\nCopyright 2008-2010  Eric Blake <ebb9@byu.net>\r\n\r\nThis is free software distributed under the GNU General Public Licence v2\r\ndescribed in the file COPYING or (at your option) any later version.\r\nThere is ABSOLUTELY NO WARRANTY, explicit or implied, on this software.\r\n\r\n\r\nDownload\r\n--------\r\n\r\n    http://ftpmirror.gnu.org/libsigsegv/libsigsegv-2.10.tar.gz\r\n    http://ftp.gnu.org/gnu/libsigsegv/libsigsegv-2.10.tar.gz\r\n    ftp://ftp.gnu.org/pub/gnu/libsigsegv/libsigsegv-2.10.tar.gz\r\n\r\nHomepage\r\n--------\r\n\r\n    http://www.gnu.org/software/libsigsegv/\r\n    http://libsigsegv.sourceforge.net/ (old)\r\n    http://savannah.gnu.org/projects/libsigsegv\r\n\r\nBug reports to\r\n--------------\r\n\r\n    <bug-libsigsegv@gnu.org>\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}